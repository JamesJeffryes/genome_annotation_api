############################################################
#
# Autogenerated by the KBase type compiler -
# any changes made here will be overwritten
#
############################################################

try:
    import json as _json
except ImportError:
    import sys
    sys.path.append('simplejson-2.3.3')
    import simplejson as _json

import requests as _requests
import urlparse as _urlparse
import random as _random
import base64 as _base64
from ConfigParser import ConfigParser as _ConfigParser
import os as _os

_CT = 'content-type'
_AJ = 'application/json'
_URL_SCHEME = frozenset(['http', 'https'])


def _get_token(user_id, password,
               auth_svc='https://nexus.api.globusonline.org/goauth/token?' +
                        'grant_type=client_credentials'):
    # This is bandaid helper function until we get a full
    # KBase python auth client released
    auth = _base64.b64encode(user_id + ':' + password)
    headers = {'Authorization': 'Basic ' + auth}
    ret = _requests.get(auth_svc, headers=headers, allow_redirects=True)
    status = ret.status_code
    if status >= 200 and status <= 299:
        tok = _json.loads(ret.text)
    elif status == 403:
        raise Exception('Authentication failed: Bad user_id/password ' +
                        'combination for user %s' % (user_id))
    else:
        raise Exception(ret.text)
    return tok['access_token']


def _read_rcfile(file=_os.environ['HOME'] + '/.authrc'):  # @ReservedAssignment
    # Another bandaid to read in the ~/.authrc file if one is present
    authdata = None
    if _os.path.exists(file):
        try:
            with open(file) as authrc:
                rawdata = _json.load(authrc)
                # strip down whatever we read to only what is legit
                authdata = {x: rawdata.get(x) for x in (
                    'user_id', 'token', 'client_secret', 'keyfile',
                    'keyfile_passphrase', 'password')}
        except Exception, e:
            print "Error while reading authrc file %s: %s" % (file, e)
    return authdata


def _read_inifile(file=_os.environ.get(  # @ReservedAssignment
                  'KB_DEPLOYMENT_CONFIG', _os.environ['HOME'] +
                  '/.kbase_config')):
    # Another bandaid to read in the ~/.kbase_config file if one is present
    authdata = None
    if _os.path.exists(file):
        try:
            config = _ConfigParser()
            config.read(file)
            # strip down whatever we read to only what is legit
            authdata = {x: config.get('authentication', x)
                        if config.has_option('authentication', x)
                        else None for x in ('user_id', 'token',
                                            'client_secret', 'keyfile',
                                            'keyfile_passphrase', 'password')}
        except Exception, e:
            print "Error while reading INI file %s: %s" % (file, e)
    return authdata


class ServerError(Exception):

    def __init__(self, name, code, message, data=None, error=None):
        self.name = name
        self.code = code
        self.message = '' if message is None else message
        self.data = data or error or ''
        # data = JSON RPC 2.0, error = 1.1

    def __str__(self):
        return self.name + ': ' + str(self.code) + '. ' + self.message + \
            '\n' + self.data


class _JSONObjectEncoder(_json.JSONEncoder):

    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        if isinstance(obj, frozenset):
            return list(obj)
        return _json.JSONEncoder.default(self, obj)


class GenomeAnnotationAPI(object):

    def __init__(self, url=None, timeout=30 * 60, user_id=None,
                 password=None, token=None, ignore_authrc=False,
                 trust_all_ssl_certificates=False):
        if url is None:
            raise ValueError('A url is required')
        scheme, _, _, _, _, _ = _urlparse.urlparse(url)
        if scheme not in _URL_SCHEME:
            raise ValueError(url + " isn't a valid http url")
        self.url = url
        self.timeout = int(timeout)
        self._headers = dict()
        self.trust_all_ssl_certificates = trust_all_ssl_certificates
        # token overrides user_id and password
        if token is not None:
            self._headers['AUTHORIZATION'] = token
        elif user_id is not None and password is not None:
            self._headers['AUTHORIZATION'] = _get_token(user_id, password)
        elif 'KB_AUTH_TOKEN' in _os.environ:
            self._headers['AUTHORIZATION'] = _os.environ.get('KB_AUTH_TOKEN')
        elif not ignore_authrc:
            authdata = _read_inifile()
            if authdata is None:
                authdata = _read_rcfile()
            if authdata is not None:
                if authdata.get('token') is not None:
                    self._headers['AUTHORIZATION'] = authdata['token']
                elif(authdata.get('user_id') is not None
                     and authdata.get('password') is not None):
                    self._headers['AUTHORIZATION'] = _get_token(
                        authdata['user_id'], authdata['password'])
        if self.timeout < 1:
            raise ValueError('Timeout value must be at least 1 second')

    def _call(self, method, params, json_rpc_context = None):
        arg_hash = {'method': method,
                    'params': params,
                    'version': '1.1',
                    'id': str(_random.random())[2:]
                    }
        if json_rpc_context:
            arg_hash['context'] = json_rpc_context

        body = _json.dumps(arg_hash, cls=_JSONObjectEncoder)
        ret = _requests.post(self.url, data=body, headers=self._headers,
                             timeout=self.timeout,
                             verify=not self.trust_all_ssl_certificates)
        if ret.status_code == _requests.codes.server_error:
            json_header = None
            if _CT in ret.headers:
                json_header = ret.headers[_CT]
            if _CT in ret.headers and ret.headers[_CT] == _AJ:
                err = _json.loads(ret.text)
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:
                    raise ServerError('Unknown', 0, ret.text)
            else:
                raise ServerError('Unknown', 0, ret.text)
        if ret.status_code != _requests.codes.OK:
            ret.raise_for_status()
        ret.encoding = 'utf-8'
        resp = _json.loads(ret.text)
        if 'result' not in resp:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')
        return resp['result']
        
 
    def get_taxon(self, inputs_get_taxon, json_rpc_context = None):
        """
        :param inputs_get_taxon: instance of type "inputs_get_taxon" (* *
           Retrieve the Taxon associated with this GenomeAnnotation. * *
           @return Reference to TaxonAPI object) -> structure: parameter
           "ref" of type "ObjectReference"
        :returns: instance of type "ObjectReference"
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_taxon: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_taxon',
                          [inputs_get_taxon], json_rpc_context)
        return resp[0]
  
    def get_assembly(self, inputs_get_assembly, json_rpc_context = None):
        """
        :param inputs_get_assembly: instance of type "inputs_get_assembly" (*
           * Retrieve the Assembly associated with this GenomeAnnotation. * *
           @return Reference to AssemblyAPI object) -> structure: parameter
           "ref" of type "ObjectReference"
        :returns: instance of type "ObjectReference"
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_assembly: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_assembly',
                          [inputs_get_assembly], json_rpc_context)
        return resp[0]
  
    def get_feature_types(self, inputs_get_feature_types, json_rpc_context = None):
        """
        :param inputs_get_feature_types: instance of type
           "inputs_get_feature_types" (* * Retrieve the list of Feature
           types. * * @return List of feature type identifiers (strings)) ->
           structure: parameter "ref" of type "ObjectReference"
        :returns: instance of list of String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_feature_types: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_feature_types',
                          [inputs_get_feature_types], json_rpc_context)
        return resp[0]
  
    def get_feature_type_descriptions(self, inputs_get_feature_type_descriptions, json_rpc_context = None):
        """
        :param inputs_get_feature_type_descriptions: instance of type
           "inputs_get_feature_type_descriptions" (optional
           feature_type_list) -> structure: parameter "ref" of type
           "ObjectReference", parameter "feature_type_list" of list of String
        :returns: instance of mapping from String to String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_feature_type_descriptions: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_feature_type_descriptions',
                          [inputs_get_feature_type_descriptions], json_rpc_context)
        return resp[0]
  
    def get_feature_type_counts(self, inputs_get_feature_type_counts, json_rpc_context = None):
        """
        :param inputs_get_feature_type_counts: instance of type
           "inputs_get_feature_type_counts" (@optional feature_type_list) ->
           structure: parameter "ref" of type "ObjectReference", parameter
           "feature_type_list" of list of String
        :returns: instance of mapping from String to Long
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_feature_type_counts: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_feature_type_counts',
                          [inputs_get_feature_type_counts], json_rpc_context)
        return resp[0]
  
    def get_feature_ids(self, inputs_get_feature_ids, json_rpc_context = None):
        """
        :param inputs_get_feature_ids: instance of type
           "inputs_get_feature_ids" (@optional filters group_by) ->
           structure: parameter "ref" of type "ObjectReference", parameter
           "filters" of type "Feature_id_filters" (* * Filters passed to
           :meth:`get_feature_ids` * @optional type_list region_list
           function_list alias_list) -> structure: parameter "type_list" of
           list of String, parameter "region_list" of list of type "Region"
           -> structure: parameter "contig_id" of String, parameter "strand"
           of String, parameter "start" of Long, parameter "length" of Long,
           parameter "function_list" of list of String, parameter
           "alias_list" of list of String, parameter "group_by" of String
        :returns: instance of type "Feature_id_mapping" (@optional by_type
           by_region by_function by_alias) -> structure: parameter "by_type"
           of mapping from String to list of String, parameter "by_region" of
           mapping from String to mapping from String to mapping from String
           to list of String, parameter "by_function" of mapping from String
           to list of String, parameter "by_alias" of mapping from String to
           list of String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_feature_ids: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_feature_ids',
                          [inputs_get_feature_ids], json_rpc_context)
        return resp[0]
  
    def get_features(self, inputs_get_features, json_rpc_context = None):
        """
        :param inputs_get_features: instance of type "inputs_get_features"
           (@optional feature_id_list exclude_sequence) -> structure:
           parameter "ref" of type "ObjectReference", parameter
           "feature_id_list" of list of String, parameter "exclude_sequence"
           of type "boolean" (A boolean - 0 for false, 1 for true. @range (0,
           1))
        :returns: instance of mapping from String to type "Feature_data" ->
           structure: parameter "feature_id" of String, parameter
           "feature_type" of String, parameter "feature_function" of String,
           parameter "feature_aliases" of mapping from String to list of
           String, parameter "feature_dna_sequence_length" of Long, parameter
           "feature_dna_sequence" of String, parameter "feature_md5" of
           String, parameter "feature_locations" of list of type "Region" ->
           structure: parameter "contig_id" of String, parameter "strand" of
           String, parameter "start" of Long, parameter "length" of Long,
           parameter "feature_publications" of list of String, parameter
           "feature_quality_warnings" of list of String, parameter
           "feature_quality_score" of list of String, parameter
           "feature_notes" of String, parameter "feature_inference" of String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_features: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_features',
                          [inputs_get_features], json_rpc_context)
        return resp[0]
  
    def get_features2(self, params, json_rpc_context = None):
        """
        Retrieve Feature data, v2.
        @param feature_id_list List of Features to retrieve.
          If None, returns all Feature data.
        @return Mapping from Feature IDs to dicts of available data.
        :param params: instance of type "GetFeatures2Params"
           (exclude_sequence = set to 1 (true) or 0 (false) to indicate if
           sequences should be included.  Defautl is false.) -> structure:
           parameter "ref" of type "ObjectReference", parameter
           "feature_id_list" of list of String, parameter "exclude_sequence"
           of type "boolean" (A boolean - 0 for false, 1 for true. @range (0,
           1))
        :returns: instance of mapping from String to type "Feature_data" ->
           structure: parameter "feature_id" of String, parameter
           "feature_type" of String, parameter "feature_function" of String,
           parameter "feature_aliases" of mapping from String to list of
           String, parameter "feature_dna_sequence_length" of Long, parameter
           "feature_dna_sequence" of String, parameter "feature_md5" of
           String, parameter "feature_locations" of list of type "Region" ->
           structure: parameter "contig_id" of String, parameter "strand" of
           String, parameter "start" of Long, parameter "length" of Long,
           parameter "feature_publications" of list of String, parameter
           "feature_quality_warnings" of list of String, parameter
           "feature_quality_score" of list of String, parameter
           "feature_notes" of String, parameter "feature_inference" of String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_features2: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_features2',
                          [params], json_rpc_context)
        return resp[0]
  
    def get_proteins(self, inputs_get_proteins, json_rpc_context = None):
        """
        :param inputs_get_proteins: instance of type "inputs_get_proteins" (*
           * Retrieve Protein data. * * @return Mapping from protein ID to
           data about the protein.) -> structure: parameter "ref" of type
           "ObjectReference"
        :returns: instance of mapping from String to type "Protein_data" ->
           structure: parameter "protein_id" of String, parameter
           "protein_amino_acid_sequence" of String, parameter
           "protein_function" of String, parameter "protein_aliases" of list
           of String, parameter "protein_md5" of String, parameter
           "protein_domain_locations" of list of String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_proteins: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_proteins',
                          [inputs_get_proteins], json_rpc_context)
        return resp[0]
  
    def get_feature_locations(self, inputs_get_feature_locations, json_rpc_context = None):
        """
        :param inputs_get_feature_locations: instance of type
           "inputs_get_feature_locations" (optional feature_id_list) ->
           structure: parameter "ref" of type "ObjectReference", parameter
           "feature_id_list" of list of String
        :returns: instance of mapping from String to list of type "Region" ->
           structure: parameter "contig_id" of String, parameter "strand" of
           String, parameter "start" of Long, parameter "length" of Long
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_feature_locations: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_feature_locations',
                          [inputs_get_feature_locations], json_rpc_context)
        return resp[0]
  
    def get_feature_publications(self, inputs_get_feature_publications, json_rpc_context = None):
        """
        :param inputs_get_feature_publications: instance of type
           "inputs_get_feature_publications" (optional feature_id_list) ->
           structure: parameter "ref" of type "ObjectReference", parameter
           "feature_id_list" of list of String
        :returns: instance of mapping from String to list of String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_feature_publications: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_feature_publications',
                          [inputs_get_feature_publications], json_rpc_context)
        return resp[0]
  
    def get_feature_dna(self, inputs_get_feature_dna, json_rpc_context = None):
        """
        :param inputs_get_feature_dna: instance of type
           "inputs_get_feature_dna" (* * Retrieve Feature DNA sequences. * *
           @param feature_id_list List of Feature IDs for which to retrieve
           sequences. *     If empty, returns data for all features. *
           @return Mapping of Feature IDs to their DNA sequence.) ->
           structure: parameter "ref" of type "ObjectReference", parameter
           "feature_id_list" of list of String
        :returns: instance of mapping from String to String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_feature_dna: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_feature_dna',
                          [inputs_get_feature_dna], json_rpc_context)
        return resp[0]
  
    def get_feature_functions(self, inputs_get_feature_functions, json_rpc_context = None):
        """
        :param inputs_get_feature_functions: instance of type
           "inputs_get_feature_functions" (@optional feature_id_list) ->
           structure: parameter "ref" of type "ObjectReference", parameter
           "feature_id_list" of list of String
        :returns: instance of mapping from String to String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_feature_functions: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_feature_functions',
                          [inputs_get_feature_functions], json_rpc_context)
        return resp[0]
  
    def get_feature_aliases(self, inputs_get_feature_aliases, json_rpc_context = None):
        """
        :param inputs_get_feature_aliases: instance of type
           "inputs_get_feature_aliases" (@optional feature_id_list) ->
           structure: parameter "ref" of type "ObjectReference", parameter
           "feature_id_list" of list of String
        :returns: instance of mapping from String to list of String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_feature_aliases: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_feature_aliases',
                          [inputs_get_feature_aliases], json_rpc_context)
        return resp[0]
  
    def get_cds_by_gene(self, inputs_get_cds_by_gene, json_rpc_context = None):
        """
        :param inputs_get_cds_by_gene: instance of type
           "inputs_get_cds_by_gene" (* * Retrieves coding sequence Features
           (cds) for given gene Feature IDs. * * @param gene_id_list List of
           gene Feature IDS for which to retrieve CDS. *     If empty,
           returns data for all features. * @return Mapping of gene Feature
           IDs to a list of CDS Feature IDs.) -> structure: parameter "ref"
           of type "ObjectReference", parameter "gene_id_list" of list of
           String
        :returns: instance of mapping from String to list of String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_cds_by_gene: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_cds_by_gene',
                          [inputs_get_cds_by_gene], json_rpc_context)
        return resp[0]
  
    def get_cds_by_mrna(self, inputs_mrna_id_list, json_rpc_context = None):
        """
        :param inputs_mrna_id_list: instance of type "inputs_mrna_id_list"
           (@optional mrna_id_list) -> structure: parameter "ref" of type
           "ObjectReference", parameter "mrna_id_list" of list of String
        :returns: instance of mapping from String to String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_cds_by_mrna: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_cds_by_mrna',
                          [inputs_mrna_id_list], json_rpc_context)
        return resp[0]
  
    def get_gene_by_cds(self, inputs_get_gene_by_cds, json_rpc_context = None):
        """
        :param inputs_get_gene_by_cds: instance of type
           "inputs_get_gene_by_cds" (@optional cds_id_list) -> structure:
           parameter "ref" of type "ObjectReference", parameter "cds_id_list"
           of list of String
        :returns: instance of mapping from String to String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_gene_by_cds: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_gene_by_cds',
                          [inputs_get_gene_by_cds], json_rpc_context)
        return resp[0]
  
    def get_gene_by_mrna(self, inputs_get_gene_by_mrna, json_rpc_context = None):
        """
        :param inputs_get_gene_by_mrna: instance of type
           "inputs_get_gene_by_mrna" (@optional mrna_id_list) -> structure:
           parameter "ref" of type "ObjectReference", parameter
           "mrna_id_list" of list of String
        :returns: instance of mapping from String to String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_gene_by_mrna: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_gene_by_mrna',
                          [inputs_get_gene_by_mrna], json_rpc_context)
        return resp[0]
  
    def get_mrna_by_cds(self, inputs_get_mrna_by_cds, json_rpc_context = None):
        """
        :param inputs_get_mrna_by_cds: instance of type
           "inputs_get_mrna_by_cds" (@optional cds_id_list) -> structure:
           parameter "ref" of type "ObjectReference", parameter "cds_id_list"
           of list of String
        :returns: instance of mapping from String to String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_mrna_by_cds: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_mrna_by_cds',
                          [inputs_get_mrna_by_cds], json_rpc_context)
        return resp[0]
  
    def get_mrna_by_gene(self, inputs_get_mrna_by_gene, json_rpc_context = None):
        """
        :param inputs_get_mrna_by_gene: instance of type
           "inputs_get_mrna_by_gene" (@optional gene_id_list) -> structure:
           parameter "ref" of type "ObjectReference", parameter
           "gene_id_list" of list of String
        :returns: instance of mapping from String to list of String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_mrna_by_gene: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_mrna_by_gene',
                          [inputs_get_mrna_by_gene], json_rpc_context)
        return resp[0]
  
    def get_mrna_exons(self, inputs_get_mrna_exons, json_rpc_context = None):
        """
        :param inputs_get_mrna_exons: instance of type
           "inputs_get_mrna_exons" (@optional mrna_id_list) -> structure:
           parameter "ref" of type "ObjectReference", parameter
           "mrna_id_list" of list of String
        :returns: instance of mapping from String to list of type "Exon_data"
           -> structure: parameter "exon_location" of type "Region" ->
           structure: parameter "contig_id" of String, parameter "strand" of
           String, parameter "start" of Long, parameter "length" of Long,
           parameter "exon_dna_sequence" of String, parameter "exon_ordinal"
           of Long
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_mrna_exons: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_mrna_exons',
                          [inputs_get_mrna_exons], json_rpc_context)
        return resp[0]
  
    def get_mrna_utrs(self, inputs_get_mrna_utrs, json_rpc_context = None):
        """
        :param inputs_get_mrna_utrs: instance of type "inputs_get_mrna_utrs"
           (@optional mrna_id_list) -> structure: parameter "ref" of type
           "ObjectReference", parameter "mrna_id_list" of list of String
        :returns: instance of mapping from String to mapping from String to
           type "UTR_data" -> structure: parameter "utr_locations" of list of
           type "Region" -> structure: parameter "contig_id" of String,
           parameter "strand" of String, parameter "start" of Long, parameter
           "length" of Long, parameter "utr_dna_sequence" of String
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_mrna_utrs: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_mrna_utrs',
                          [inputs_get_mrna_utrs], json_rpc_context)
        return resp[0]
  
    def get_summary(self, inputs_get_summary, json_rpc_context = None):
        """
        :param inputs_get_summary: instance of type "inputs_get_summary" (* *
           Retrieve a summary representation of this GenomeAnnotation. * *
           @return summary data) -> structure: parameter "ref" of type
           "ObjectReference"
        :returns: instance of type "Summary_data" -> structure: parameter
           "scientific_name" of String, parameter "taxonomy_id" of Long,
           parameter "kingdom" of String, parameter "scientific_lineage" of
           list of String, parameter "genetic_code" of Long, parameter
           "organism_aliases" of list of String, parameter "assembly_source"
           of String, parameter "assembly_source_id" of String, parameter
           "assembly_source_date" of String, parameter "gc_content" of
           Double, parameter "dna_size" of Long, parameter "num_contigs" of
           Long, parameter "contig_ids" of list of String, parameter
           "external_source" of String, parameter "external_source_date" of
           String, parameter "release" of String, parameter
           "original_source_filename" of String, parameter
           "feature_type_counts" of mapping from String to Long
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method get_summary: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.get_summary',
                          [inputs_get_summary], json_rpc_context)
        return resp[0]
  
    def save_summary(self, inputs_save_summary, json_rpc_context = None):
        """
        :param inputs_save_summary: instance of type "inputs_save_summary" (*
           * Retrieve a summary representation of this GenomeAnnotation. * *
           @return (int, Summary_data)) -> structure: parameter "ref" of type
           "ObjectReference"
        :returns: multiple set - (1) instance of Long, (2) instance of type
           "Summary_data" -> structure: parameter "scientific_name" of
           String, parameter "taxonomy_id" of Long, parameter "kingdom" of
           String, parameter "scientific_lineage" of list of String,
           parameter "genetic_code" of Long, parameter "organism_aliases" of
           list of String, parameter "assembly_source" of String, parameter
           "assembly_source_id" of String, parameter "assembly_source_date"
           of String, parameter "gc_content" of Double, parameter "dna_size"
           of Long, parameter "num_contigs" of Long, parameter "contig_ids"
           of list of String, parameter "external_source" of String,
           parameter "external_source_date" of String, parameter "release" of
           String, parameter "original_source_filename" of String, parameter
           "feature_type_counts" of mapping from String to Long
        """
        if json_rpc_context and type(json_rpc_context) is not dict:
            raise ValueError('Method save_summary: argument json_rpc_context is not type dict as required.')
        resp = self._call('GenomeAnnotationAPI.save_summary',
                          [inputs_save_summary], json_rpc_context)
        return resp
 